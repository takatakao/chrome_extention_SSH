"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

function _convertSourceMap() {
  var data = _interopRequireDefault(require("convert-source-map"));

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _defaults() {
  var data = _interopRequireDefault(require("lodash/defaults"));

  _defaults = function _defaults() {
    return data;
  };

  return data;
}

function _sourceMap() {
  var data = _interopRequireDefault(require("source-map"));

  _sourceMap = function _sourceMap() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require("slash"));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  var data = _interopRequireDefault(require("fs"));

  _fs = function _fs() {
    return data;
  };

  return data;
}

var util = _interopRequireWildcard(require("./util"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _default(_x) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5(_ref3) {
    var cliOptions, babelOptions, buildResult, output, readStdin, stdin, _stdin, walk, _walk, files, _files;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _files = function _ref12() {
              _files = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee4(filenames) {
                var chokidar;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (cliOptions.skipInitialBuild) {
                          _context4.next = 3;
                          break;
                        }

                        _context4.next = 3;
                        return walk(filenames);

                      case 3:
                        if (cliOptions.watch) {
                          chokidar = util.requireChokidar();
                          chokidar.watch(filenames, {
                            persistent: true,
                            ignoreInitial: true,
                            awaitWriteFinish: {
                              stabilityThreshold: 50,
                              pollInterval: 10
                            }
                          }).on("all", function (type, filename) {
                            if (!util.isCompilableExtension(filename, cliOptions.extensions)) {
                              return;
                            }

                            if (type === "add" || type === "change") {
                              if (cliOptions.verbose) {
                                console.log(type + " " + filename);
                              }

                              walk(filenames)["catch"](function (err) {
                                console.error(err);
                              });
                            }
                          });
                        }

                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              return _files.apply(this, arguments);
            };

            files = function _ref11(_x3) {
              return _files.apply(this, arguments);
            };

            _walk = function _ref10() {
              _walk = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee3(filenames) {
                var _filenames, results;

                return regeneratorRuntime.wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        _filenames = [];
                        filenames.forEach(function (filename) {
                          if (!_fs()["default"].existsSync(filename)) return;

                          var stat = _fs()["default"].statSync(filename);

                          if (stat.isDirectory()) {
                            var dirname = filename;
                            util.readdirForCompilable(filename, cliOptions.includeDotfiles, cliOptions.extensions).forEach(function (filename) {
                              _filenames.push(_path()["default"].join(dirname, filename));
                            });
                          } else {
                            _filenames.push(filename);
                          }
                        });
                        _context3.next = 4;
                        return Promise.all(_filenames.map(function () {
                          var _ref2 = _asyncToGenerator(
                          /*#__PURE__*/
                          regeneratorRuntime.mark(function _callee2(filename) {
                            var sourceFilename;
                            return regeneratorRuntime.wrap(function _callee2$(_context2) {
                              while (1) {
                                switch (_context2.prev = _context2.next) {
                                  case 0:
                                    sourceFilename = filename;

                                    if (cliOptions.outFile) {
                                      sourceFilename = _path()["default"].relative(_path()["default"].dirname(cliOptions.outFile), sourceFilename);
                                    }

                                    sourceFilename = (0, _slash()["default"])(sourceFilename);
                                    _context2.prev = 3;
                                    _context2.next = 6;
                                    return util.compile(filename, (0, _defaults()["default"])({
                                      sourceFileName: sourceFilename,
                                      sourceMaps: babelOptions.sourceMaps === "inline" ? true : babelOptions.sourceMaps
                                    }, babelOptions));

                                  case 6:
                                    return _context2.abrupt("return", _context2.sent);

                                  case 9:
                                    _context2.prev = 9;
                                    _context2.t0 = _context2["catch"](3);

                                    if (cliOptions.watch) {
                                      _context2.next = 13;
                                      break;
                                    }

                                    throw _context2.t0;

                                  case 13:
                                    console.error(_context2.t0);
                                    return _context2.abrupt("return", null);

                                  case 15:
                                  case "end":
                                    return _context2.stop();
                                }
                              }
                            }, _callee2, null, [[3, 9]]);
                          }));

                          return function (_x4) {
                            return _ref2.apply(this, arguments);
                          };
                        }()));

                      case 4:
                        results = _context3.sent;
                        output(results);

                      case 6:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3);
              }));
              return _walk.apply(this, arguments);
            };

            walk = function _ref9(_x2) {
              return _walk.apply(this, arguments);
            };

            _stdin = function _ref8() {
              _stdin = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee() {
                var code, res;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return readStdin();

                      case 2:
                        code = _context.sent;
                        _context.next = 5;
                        return util.transform(cliOptions.filename, code, (0, _defaults()["default"])({
                          sourceFileName: "stdin"
                        }, babelOptions));

                      case 5:
                        res = _context.sent;
                        output([res]);

                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              return _stdin.apply(this, arguments);
            };

            stdin = function _ref7() {
              return _stdin.apply(this, arguments);
            };

            readStdin = function _ref6() {
              return new Promise(function (resolve, reject) {
                var code = "";
                process.stdin.setEncoding("utf8");
                process.stdin.on("readable", function () {
                  var chunk = process.stdin.read();
                  if (chunk !== null) code += chunk;
                });
                process.stdin.on("end", function () {
                  resolve(code);
                });
                process.stdin.on("error", reject);
              });
            };

            output = function _ref5(fileResults) {
              var result = buildResult(fileResults);

              if (cliOptions.outFile) {
                if (babelOptions.sourceMaps && babelOptions.sourceMaps !== "inline") {
                  var mapLoc = cliOptions.outFile + ".map";
                  result.code = util.addSourceMappingUrl(result.code, mapLoc);

                  _fs()["default"].writeFileSync(mapLoc, JSON.stringify(result.map));
                }

                _fs()["default"].writeFileSync(cliOptions.outFile, result.code);
              } else {
                process.stdout.write(result.code + "\n");
              }
            };

            buildResult = function _ref4(fileResults) {
              var map = new (_sourceMap()["default"].SourceMapGenerator)({
                file: cliOptions.sourceMapTarget || _path()["default"].basename(cliOptions.outFile || "") || "stdout",
                sourceRoot: babelOptions.sourceRoot
              });
              var code = "";
              var offset = 0;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = fileResults[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var result = _step.value;
                  if (!result) continue;
                  code += result.code + "\n";

                  if (result.map) {
                    (function () {
                      var consumer = new (_sourceMap()["default"].SourceMapConsumer)(result.map);
                      var sources = new Set();
                      consumer.eachMapping(function (mapping) {
                        if (mapping.source != null) sources.add(mapping.source);
                        map.addMapping({
                          generated: {
                            line: mapping.generatedLine + offset,
                            column: mapping.generatedColumn
                          },
                          source: mapping.source,
                          original: mapping.source == null ? null : {
                            line: mapping.originalLine,
                            column: mapping.originalColumn
                          }
                        });
                      });
                      sources.forEach(function (source) {
                        var content = consumer.sourceContentFor(source, true);

                        if (content !== null) {
                          map.setSourceContent(source, content);
                        }
                      });
                      offset = code.split("\n").length - 1;
                    })();
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              if (babelOptions.sourceMaps === "inline" || !cliOptions.outFile && babelOptions.sourceMaps) {
                code += "\n" + _convertSourceMap()["default"].fromObject(map).toComment();
              }

              return {
                map: map,
                code: code
              };
            };

            cliOptions = _ref3.cliOptions, babelOptions = _ref3.babelOptions;

            if (!cliOptions.filenames.length) {
              _context5.next = 15;
              break;
            }

            _context5.next = 13;
            return files(cliOptions.filenames);

          case 13:
            _context5.next = 17;
            break;

          case 15:
            _context5.next = 17;
            return stdin();

          case 17:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _ref.apply(this, arguments);
}